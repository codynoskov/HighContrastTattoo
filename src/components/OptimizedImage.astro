---
/**
 * OptimizedImage - Uses Astro's built-in Image component for optimization
 * 
 * Supports three image source types:
 * 1. Remote URLs (http/https) - Served directly from CDN
 * 2. Imported images (ImageMetadata) - Full build-time optimization with WebP
 * 3. Local paths (/images/...) - Automatically resolved to ImageMetadata for optimization
 * 
 * For responsive images, use `widths` + `sizes` to generate srcset:
 * - widths: Array of pixel widths to generate (e.g., [400, 800, 1200])
 * - sizes: Browser hints for which size to pick (e.g., "(max-width: 768px) 100vw, 50vw")
 */
import { Image } from 'astro:assets';
import type { ImageMetadata } from 'astro';
import { getImageMetadata } from '../utils/imageResolver';

interface Props {
  src: string | ImageMetadata;
  alt: string;
  width?: number;
  height?: number;
  widths?: number[]; // Generate multiple sizes for srcset (e.g., [400, 800, 1200])
  aspectRatio?: number; // width / height
  sizes?: string; // Browser hints for srcset (e.g., "(max-width: 768px) 100vw, 50vw")
  loading?: 'lazy' | 'eager';
  className?: string;
  fallbackSrc?: string;
  quality?: number; // 1-100, default 80
}

const {
  src: rawSrc,
  alt,
  width,
  height,
  widths,
  aspectRatio,
  sizes,
  loading = 'lazy',
  className = '',
  fallbackSrc,
  quality = 80,
} = Astro.props;

// Determine the type of image source
const isImageMetadataInput = typeof rawSrc === 'object' && rawSrc !== null && 'src' in rawSrc;
const isRemoteUrl = typeof rawSrc === 'string' && (rawSrc.startsWith('http://') || rawSrc.startsWith('https://'));
const isLocalPath = typeof rawSrc === 'string' && rawSrc.startsWith('/');
const hasSrc = rawSrc && (isImageMetadataInput || (typeof rawSrc === 'string' && rawSrc.length > 0));

// For local paths, try to resolve to ImageMetadata for optimization
let resolvedSrc: string | ImageMetadata = rawSrc;
let isImageMetadata = isImageMetadataInput;

if (isLocalPath && typeof rawSrc === 'string') {
  const metadata = getImageMetadata(rawSrc);
  if (metadata) {
    resolvedSrc = metadata;
    isImageMetadata = true;
  }
}

// Calculate dimensions if aspectRatio is provided
let finalWidth = width;
let finalHeight = height;

if (aspectRatio && finalWidth && !finalHeight) {
  finalHeight = Math.round(finalWidth / aspectRatio);
} else if (aspectRatio && finalHeight && !finalWidth) {
  finalWidth = Math.round(finalHeight * aspectRatio);
}

// For remote images, we need BOTH dimensions for Astro's Image component
// If we have aspectRatio, we can calculate the missing dimension
if (aspectRatio) {
  if (finalWidth && !finalHeight) {
    finalHeight = Math.round(finalWidth / aspectRatio);
  } else if (finalHeight && !finalWidth) {
    finalWidth = Math.round(finalHeight * aspectRatio);
  } else if (!finalWidth && !finalHeight) {
    // Default dimensions when neither is provided
    finalWidth = 800;
    finalHeight = Math.round(finalWidth / aspectRatio);
  }
}

// For remote images without dimensions, use sensible defaults instead of inferSize
// inferSize can cause issues with very large images and is slower
if (isRemoteUrl && (!finalWidth || !finalHeight)) {
  // Default to a reasonable size for remote images
  if (!finalWidth) finalWidth = 800;
  if (!finalHeight) finalHeight = 800; // Square as fallback
}

// For images with metadata (imported or resolved from local path), get dimensions if not specified
if (isImageMetadata && !finalWidth && !finalHeight && !widths) {
  const metadata = resolvedSrc as ImageMetadata;
  finalWidth = metadata.width;
  finalHeight = metadata.height;
}

// When using widths for srcset, we need to provide a fallback width for the width attribute
// Use the largest width in the array, or default to 800
const srcsetFallbackWidth = widths ? Math.max(...widths) : undefined;

// Determine if we should use srcset mode (widths array provided)
const useSrcset = widths && widths.length > 0 && isImageMetadata;
---

{!hasSrc ? (
  /* No valid src - render fallback or nothing */
  fallbackSrc ? (
    <img
      src={fallbackSrc}
      alt={alt}
      width={finalWidth}
      height={finalHeight}
      loading={loading}
      class={className}
    />
  ) : null
) : useSrcset ? (
  /* Responsive image with srcset - generates multiple sizes */
  <Image
    src={resolvedSrc as ImageMetadata}
    alt={alt}
    widths={widths}
    sizes={sizes}
    quality={quality}
    loading={loading}
    class={className}
    format="webp"
    style="width: 100%; height: 100%; object-fit: cover; object-position: center;"
  />
) : isImageMetadata ? (
  /* Single-size optimized image */
  <Image
    src={resolvedSrc as ImageMetadata}
    alt={alt}
    width={finalWidth}
    height={finalHeight}
    quality={quality}
    loading={loading}
    class={className}
    format="webp"
    style="width: 100%; height: 100%; object-fit: cover; object-position: center;"
  />
) : isRemoteUrl ? (
  /* Remote URL - serve directly from CDN without build-time processing */
  <img
    src={resolvedSrc as string}
    alt={alt}
    width={finalWidth}
    height={finalHeight}
    loading={loading}
    class={className}
    style="width: 100%; height: 100%; object-fit: cover; object-position: center;"
    onerror={fallbackSrc ? `this.src='${fallbackSrc}'; this.onerror=null;` : undefined}
  />
) : (
  /* Fallback for unresolved local paths or other strings */
  <img
    src={resolvedSrc as string}
    alt={alt}
    width={finalWidth}
    height={finalHeight}
    loading={loading}
    class={className}
    style="width: 100%; height: 100%; object-fit: cover; object-position: center;"
    onerror={fallbackSrc ? `this.src='${fallbackSrc}'; this.onerror=null;` : undefined}
  />
)}

<style>
  :global(.optimized-image) {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    display: block;
  }
</style>

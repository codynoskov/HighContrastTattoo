---
import Tag from './Tag.astro';
import Icon from './Icon.astro';
import Lightbox from './Lightbox.astro';
import OptimizedImage from './OptimizedImage.astro';
import imagePlaceholder from '../assets/images/image-placeholder.png';
import type { ImageMetadata } from 'astro';

interface GalleryImage {
  src: string | ImageMetadata;
  alt?: string;
  tags?: Array<{
    text: string;
    color?: "Primary" | "Accent" | "Neutral";
    href?: string;
  }>;
}

interface Props {
  images: GalleryImage[];
  className?: string;
  maxVisible?: number;
  sharedGalleryId?: string; // ID of shared lightbox (used on artist/style pages)
  imageOffset?: number; // Offset for mapping local indices to global indices
  mobileColumns?: 1 | 2; // Number of columns on mobile (default: 2)
}

const { images = [], className = "", maxVisible = 6, sharedGalleryId, imageOffset = 0, mobileColumns = 2 } = Astro.props;

// Each gallery instance gets its own unique ID for item selection
const instanceId = `gallery-${Math.random().toString(36).substring(2, 11)}`;
// Use shared gallery ID for lightbox if provided, otherwise use instance ID
const lightboxGalleryId = sharedGalleryId || instanceId;

const MAX_VISIBLE_IMAGES = maxVisible;
const visibleImages = images.slice(0, MAX_VISIBLE_IMAGES);
const hasMoreImages = images.length > MAX_VISIBLE_IMAGES;
const allImages = images;
---

<div class={`gallery ${className}`} data-gallery-instance-id={instanceId} data-lightbox-gallery-id={lightboxGalleryId} data-image-offset={imageOffset} data-mobile-columns={mobileColumns}>
  <div class="gallery-grid">
    {visibleImages.map((image, index) => (
      <div 
        class={`gallery-item ${index === MAX_VISIBLE_IMAGES - 1 && hasMoreImages ? 'gallery-item-overlay' : ''}`}
        data-image-index={index}
        data-gallery-instance-id={instanceId}
      >
        <div class="gallery-image-container">
          <OptimizedImage
            src={image.src || imagePlaceholder}
            alt={image.alt || `Gallery image ${index + 1}`}
            aspectRatio={1}
            widths={[300, 500, 800]}
            sizes="(max-width: 767px) 50vw, 33vw"
            loading="lazy"
            className="gallery-image"
            fallbackSrc={imagePlaceholder.src}
            quality={85}
          />
        </div>
        {image.tags && image.tags.length > 0 && !(index === MAX_VISIBLE_IMAGES - 1 && hasMoreImages) ? (
          <div class="gallery-tags">
            {image.tags.map((tag) => (
              <Tag color={tag.color || "Primary"} href={tag.href}>{tag.text}</Tag>
            ))}
          </div>
        ) : null}
        {index === MAX_VISIBLE_IMAGES - 1 && hasMoreImages && (
          <div class="gallery-overlay">
            <div class="gallery-overlay-content">
              <span class="gallery-overlay-text">Show all</span>
              <Icon name="image-multiple" size={24} />
            </div>
          </div>
        )}
      </div>
    ))}
  </div>

  <!-- Only render Lightbox if this is NOT using a shared lightbox -->
  {!sharedGalleryId && (
    <Lightbox images={allImages} galleryId={instanceId} />
  )}
</div>

<script define:vars={{ instanceId, lightboxGalleryId, imageOffset }}>
  // Gallery lightbox functionality - scoped to this instance
  (function() {
    const galleryContainer = document.querySelector(`[data-gallery-instance-id="${instanceId}"]`);
    if (!galleryContainer) return;

    // Use the lightbox gallery ID for the lightbox element
    const lightboxId = `${lightboxGalleryId}-lightbox`;
    
    // Wait for lightbox to be available (especially important for shared lightboxes)
    let retryCount = 0;
    const maxRetries = 20; // Maximum 1 second wait (20 * 50ms)
    function waitForLightbox(callback) {
      const lightbox = document.getElementById(lightboxId);
      if (lightbox) {
        callback(lightbox);
      } else if (retryCount < maxRetries) {
        retryCount++;
        // Retry after a short delay if lightbox doesn't exist yet
        setTimeout(() => waitForLightbox(callback), 50);
      } else {
        console.warn(`Lightbox ${lightboxId} not found after ${maxRetries} retries`);
      }
    }
    
    waitForLightbox((lightbox) => {
      initializeGallery(lightbox);
    });
    
    function initializeGallery(lightbox) {

    const slides = lightbox.querySelectorAll('.gallery-lightbox-slide');
    const prevButton = lightbox.querySelector('.gallery-lightbox-prev');
    const nextButton = lightbox.querySelector('.gallery-lightbox-next');
    const closeButton = lightbox.querySelector('.gallery-lightbox-close');
    const backdrop = lightbox.querySelector('.gallery-lightbox-backdrop');
    const lightboxContent = lightbox.querySelector('.gallery-lightbox-content');
    
    const totalImages = slides.length;

    // Get current index from lightbox data attribute (shared state)
    function getCurrentIndex() {
      const stored = lightbox.dataset.currentIndex;
      if (stored !== undefined) {
        return parseInt(stored, 10);
      }
      // Find which slide is currently visible
      for (let i = 0; i < slides.length; i++) {
        if (slides[i].style.display === 'flex' || 
            (slides[i].style.display === '' && i === 0)) {
          return i;
        }
      }
      return 0;
    }

    // Set current index in lightbox data attribute (shared state)
    function setCurrentIndex(index) {
      lightbox.dataset.currentIndex = index.toString();
    }

    // Update counter for the active slide
    function updateCounter() {
      const currentIndex = getCurrentIndex();
      slides.forEach((slide, i) => {
        const currentCounter = slide.querySelector('.gallery-lightbox-current');
        if (currentCounter && i === currentIndex) {
          currentCounter.textContent = (currentIndex + 1).toString();
        }
      });
    }

    // Show slide
    function showSlide(index) {
      // Loop around if out of bounds
      if (index < 0) {
        index = totalImages - 1;
      } else if (index >= totalImages) {
        index = 0;
      }
      
      setCurrentIndex(index);
      slides.forEach((slide, i) => {
        slide.style.display = i === index ? 'flex' : 'none';
      });
      
      updateCounter();
      
      // Remove disabled state for looping slideshow
      if (prevButton) {
        prevButton.disabled = false;
        prevButton.classList.remove('disabled');
      }
      if (nextButton) {
        nextButton.disabled = false;
        nextButton.classList.remove('disabled');
      }
    }

    // Open lightbox
    function openLightbox(index) {
      if (index < 0 || index >= totalImages) return;
      
      lightbox.classList.add('active');
      document.body.style.overflow = 'hidden';
      showSlide(index);
    }

    // Close lightbox
    function closeLightbox() {
      lightbox.classList.remove('active');
      document.body.style.overflow = '';
    }

    // Navigation handlers - only set up once per lightbox
    if (!lightbox.dataset.controlsInitialized) {
      lightbox.dataset.controlsInitialized = 'true';

      // Navigation
      if (prevButton) {
        prevButton.addEventListener('click', (e) => {
          e.stopPropagation();
          const currentIndex = getCurrentIndex();
          showSlide(currentIndex - 1);
        });
      }

      if (nextButton) {
        nextButton.addEventListener('click', (e) => {
          e.stopPropagation();
          const currentIndex = getCurrentIndex();
          showSlide(currentIndex + 1);
        });
      }

      if (closeButton) {
        closeButton.addEventListener('click', closeLightbox);
      }

      if (backdrop) {
        backdrop.addEventListener('click', closeLightbox);
      }

      // Close when clicking on the content area (but not on the image itself)
      if (lightboxContent) {
        lightboxContent.addEventListener('click', (e) => {
          // Close if clicking on the content container or slides container, but not on the image or tags
          const clickedElement = e.target;
          const isImage = clickedElement.tagName === 'IMG';
          const isTag = clickedElement.closest('.tag') !== null;
          const isCounter = clickedElement.closest('.gallery-lightbox-counter') !== null;
          
          if (!isImage && !isTag && !isCounter) {
            closeLightbox();
          }
        });
      }

      // Keyboard navigation - only when this lightbox is active
      function handleKeydown(e) {
        if (!lightbox.classList.contains('active')) return;
        
        if (e.key === 'Escape') {
          closeLightbox();
        } else if (e.key === 'ArrowLeft') {
          const currentIndex = getCurrentIndex();
          showSlide(currentIndex - 1);
        } else if (e.key === 'ArrowRight') {
          const currentIndex = getCurrentIndex();
          showSlide(currentIndex + 1);
        }
      }
      document.addEventListener('keydown', handleKeydown);

      // Swipe gesture detection for mobile
      let touchStartX = 0;
      let touchStartY = 0;
      let touchEndX = 0;
      let touchEndY = 0;
      const minSwipeDistance = 50; // Minimum distance in pixels for a swipe

      function handleTouchStart(e) {
        if (!lightbox.classList.contains('active')) return;
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
      }

      function handleTouchEnd(e) {
        if (!lightbox.classList.contains('active')) return;
        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;
        handleSwipe();
      }

      function handleSwipe() {
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const absDeltaX = Math.abs(deltaX);
        const absDeltaY = Math.abs(deltaY);

        // Only process horizontal swipes (ignore vertical scrolling)
        if (absDeltaX > absDeltaY && absDeltaX > minSwipeDistance) {
          const currentIndex = getCurrentIndex();
          if (deltaX > 0) {
            // Swipe right - go to previous slide
            showSlide(currentIndex - 1);
          } else {
            // Swipe left - go to next slide
            showSlide(currentIndex + 1);
          }
        }
      }

      // Add touch event listeners to the lightbox content
      if (lightboxContent) {
        lightboxContent.addEventListener('touchstart', handleTouchStart, { passive: true });
        lightboxContent.addEventListener('touchend', handleTouchEnd, { passive: true });
      }
    }

    // Gallery item click handlers - scoped to this Gallery instance only
    const galleryItems = galleryContainer.querySelectorAll(`.gallery-item[data-gallery-instance-id="${instanceId}"]`);
    galleryItems.forEach((item) => {
      item.addEventListener('click', () => {
        const localIndex = parseInt(item.dataset.imageIndex || '0');
        
        // Map local index to global index using the offset
        const globalIndex = imageOffset + localIndex;
        
        openLightbox(globalIndex);
      });
    });

      // Initialize - hide all slides except first (only if not already initialized)
      if (!lightbox.dataset.initialized) {
        slides.forEach((slide, i) => {
          slide.style.display = i === 0 ? 'flex' : 'none';
        });
        setCurrentIndex(0);
        lightbox.dataset.initialized = 'true';
      }
      updateCounter();
    }
  })();
</script>

<style>
  .gallery {
    width: 100%;
    max-width: none;
    min-width: 0;
  }

  .gallery-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-auto-rows: 1fr;
    gap: var(--spacing-core-500-md);
    width: 100%;
    max-width: none;
    min-width: 0;
  }

  .gallery-item {
    position: relative;
    aspect-ratio: 1 / 1;
    width: 100%;
    overflow: hidden;
    cursor: pointer;
    display: flex;
    flex-direction: column;
  }

  .gallery-image-container {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    flex: 1;
    min-height: 0;
  }

  .gallery-image-container :global(img),
  .gallery-image-container :global(picture) {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: 50% 50%;
    transition: transform 0.3s ease;
    display: block;
  }

  .gallery-image-container :global(img) {
    width: 100%;
    height: 100%;
  }

  .gallery-item:hover .gallery-image-container :global(img) {
    transform: scale(1.05);
  }

  .gallery-tags {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-core-500-md);
    padding: var(--spacing-core-500-md);
    pointer-events: none;
  }

  .gallery-tags :global(.tag) {
    pointer-events: auto;
  }

  /* Overlay for "Show all" */
  .gallery-item-overlay {
    position: relative;
  }

  .gallery-item-overlay .gallery-tags {
    display: none;
  }

  .gallery-overlay {
    position: absolute;
    inset: 0;
    background-color: var(--color-primary-50);
    opacity: 0.84;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: var(--spacing-core-600-md);
    cursor: pointer;
    z-index: 10;
  }

  .gallery-overlay-content {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--spacing-core-600-md);
    padding: var(--spacing-core-600-md) 0;
  }

  .gallery-overlay-text {
    font: var(--typography-link);
    color: var(--color-primary-900);
    text-transform: uppercase;
    letter-spacing: var(--letter-spacing-core-100-md);
  }

  .gallery-overlay :global(.icon) {
    color: var(--color-primary-900);
  }

  /* Mobile Breakpoint - 767px and below */
  @media (max-width: 767px) {
    .gallery-grid {
      grid-template-columns: repeat(2, 1fr);
      grid-auto-rows: 1fr;
    }

    /* Single column on mobile when specified */
    .gallery[data-mobile-columns="1"] .gallery-grid {
      grid-template-columns: 1fr;
    }

    .gallery-item {
      width: 100%;
    }
  }
</style>

---
import Card from '../Card.astro';
import Button from '../Button.astro';
import CarouselNav from '../CarouselNav.astro';
import imagePlaceholder from '../../assets/images/image-placeholder.png';
import { getCollection } from 'astro:content';
import { getSlug, getWorksByStyle, resolveImage, resolveArtist, getArtistSlugsFromWork } from '../../utils/contentHelpers';
import type { ImageMetadata } from 'astro';

interface Props {
  title?: string;
  description?: string;
  ctaText?: string;
  ctaHref?: string;
  className?: string;
}

// Fetch content collections
const styleEntries = await getCollection('styles');
const worksEntries = await getCollection('works');
const artistEntries = await getCollection('artists');

// Sort styles by order if defined, otherwise alphabetically
const sortedStyles = [...styleEntries].sort((a, b) => {
  // If both have order, sort by order
  if (a.data.order !== undefined && b.data.order !== undefined) {
    return a.data.order - b.data.order;
  }
  
  // If only one has order, it comes first
  if (a.data.order !== undefined) return -1;
  if (b.data.order !== undefined) return 1;
  
  // If neither has order, sort alphabetically by name
  return a.data.name.localeCompare(b.data.name);
});

// Track used images to avoid repetition (using string keys for comparison)
const usedImageKeys = new Set<string>();

// Helper to get a unique key for an image (works for both ImageMetadata and string)
function getImageKey(img: ImageMetadata | string): string {
  if (typeof img === 'string') return img;
  return img.src;
}

// Helper to check if a resolved image is valid (ImageMetadata or remote URL)
function isValidImage(img: ImageMetadata | string): boolean {
  if (!img) return false;
  // ImageMetadata objects are valid
  if (typeof img === 'object' && img !== null && 'src' in img) return true;
  // Remote URLs are valid
  if (typeof img === 'string' && (img.startsWith('http://') || img.startsWith('https://'))) return true;
  // Local path strings are not valid (file might not exist)
  return false;
}

// Transform styles into card format
const stylesData = sortedStyles.map((entry) => {
  const slug = getSlug(entry);
  const styleWorks = getWorksByStyle(slug, worksEntries);
  
  let image: ImageMetadata | string = imagePlaceholder;
  
  // Priority 1: Use cardImage if available and valid
  if (entry.data.cardImage) {
    const resolved = resolveImage(entry.data.cardImage);
    if (isValidImage(resolved)) {
      image = resolved;
      usedImageKeys.add(getImageKey(image));
    }
  } 
  // Priority 2: Use an unused work image (only if valid)
  if (image === imagePlaceholder && styleWorks.length > 0) {
    for (const work of styleWorks) {
      const workImage = resolveImage(work.data.image);
      if (isValidImage(workImage)) {
        const key = getImageKey(workImage);
        if (!usedImageKeys.has(key)) {
          image = workImage;
          usedImageKeys.add(key);
          break;
        }
      }
    }
  }
  // Priority 3: Use placeholder (already set as default)
  
  // Get artist links who work in this style (flatten arrays and deduplicate)
  const artistSlugs = [...new Set(styleWorks.flatMap(work => getArtistSlugsFromWork(work)))];
  const artistLinks = artistSlugs
    .map(slug => resolveArtist(slug, artistEntries))
    .filter((artist): artist is { name: string; href: string } => artist !== undefined);
  
  return {
    title: entry.data.name,
    description: entry.data.intro,
    image,
    artistLinks,
    href: `/styles/${slug}`
  };
});

const {
  title = "Explore the Styles",
  description = "From neo-traditional and blackwork to lettering and geometric designs, our artists cover a wide range of styles.",
  ctaText = "Explore all Styles",
  ctaHref = "/styles",
  className = ""
} = Astro.props;
---

<section class={`section section--carousel ${className}`}>
  <div class="container">
    <div class="section-text-block">
      <h2 class="section-title">{title}</h2>
      <p class="section-description">{description}</p>
    </div>
    <div class="section-actions-row">
      <div class="section-action">
        <Button 
          type="Secondary" 
          color="Primary"
          href={ctaHref}
          leadingIcon={false}
          trailingIcon={true}
        >
          {ctaText}
        </Button>
      </div>
      <CarouselNav carouselId="styles-carousel" />
    </div>
  </div>
  
  <div class="carousel-wrapper" style="margin-top: var(--spacing-core-900-md);">
    <div class="carousel" id="styles-carousel">
      <div class="carousel-track">
        {stylesData.map((style) => (
          <Card 
            type="Style"
            fillHeight={false}
            title={style.title}
            description={style.description}
            descriptionSize="md"
            image={style.image}
            artistLinks={style.artistLinks}
            href={style.href}
          />
        ))}
      </div>
    </div>
  </div>
</section>

<style>
  .section-actions-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--spacing-core-800-md);
    margin-top: var(--spacing-core-600-md);
    width: 100%;
  }

  @media (max-width: 767px) {
    .section-actions-row {
      justify-content: flex-start;
    }
  }
</style>

<script>
  // Carousel navigation functionality
  function initCarouselNav(carouselId: string) {
    const carousel = document.getElementById(carouselId);
    const navContainer = document.querySelector(`[data-carousel-nav="${carouselId}"]`);
    
    if (!carousel || !navContainer) return;
    
    const prevBtn = navContainer.querySelector('[data-direction="prev"]') as HTMLButtonElement;
    const nextBtn = navContainer.querySelector('[data-direction="next"]') as HTMLButtonElement;
    
    if (!prevBtn || !nextBtn) return;
    
    function updateNavVisibility() {
      if (!carousel || !navContainer) return;
      
      const isScrollable = carousel.scrollWidth > carousel.clientWidth;
      const atStart = carousel.scrollLeft <= 1;
      const atEnd = carousel.scrollLeft >= carousel.scrollWidth - carousel.clientWidth - 1;
      
      // Hide entire nav if not scrollable
      if (!isScrollable) {
        (navContainer as HTMLElement).style.display = 'none';
        return;
      }
      
      // Show nav on desktop
      if (window.innerWidth >= 768) {
        (navContainer as HTMLElement).style.display = 'flex';
      }
      
      // Toggle individual button visibility
      prevBtn.setAttribute('data-hidden', atStart ? 'true' : 'false');
      nextBtn.setAttribute('data-hidden', atEnd ? 'true' : 'false');
    }
    
    function scrollCarousel(direction: 'prev' | 'next') {
      if (!carousel) return;
      
      if (direction === 'next') {
        // Find first card that's partially or fully cut off on the right
        const cards = carousel.querySelectorAll('.card');
        if (!cards.length) return;
        
        const containerRect = carousel.getBoundingClientRect();
        const scrollPadding = parseFloat(getComputedStyle(carousel).scrollPaddingLeft) || 0;
        
        for (const card of cards) {
          const cardRect = card.getBoundingClientRect();
          // If card's right edge is beyond the container's right edge (with small tolerance)
          if (cardRect.right > containerRect.right + 1) {
            carousel.scrollTo({
              left: carousel.scrollLeft + (cardRect.left - containerRect.left) - scrollPadding,
              behavior: 'smooth'
            });
            break;
          }
        }
      } else {
        // Scroll back by container width
        const scrollAmount = carousel.clientWidth;
        carousel.scrollBy({
          left: -scrollAmount,
          behavior: 'smooth'
        });
      }
    }
    
    prevBtn.addEventListener('click', () => scrollCarousel('prev'));
    nextBtn.addEventListener('click', () => scrollCarousel('next'));
    carousel.addEventListener('scroll', updateNavVisibility);
    window.addEventListener('resize', updateNavVisibility);
    
    // Ensure carousel starts at the beginning and update nav visibility
    carousel.scrollLeft = 0;
    updateNavVisibility();
  }
  
  // Initialize on DOM ready with a frame delay to ensure layout is complete
  function init() {
    requestAnimationFrame(() => {
      initCarouselNav('styles-carousel');
    });
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
